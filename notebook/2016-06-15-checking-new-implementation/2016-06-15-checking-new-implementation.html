<p>All functions have been reimplemented partly because the new .csv files created from html tables are organized differently than the ones from Ifat, and partly to make code simpler, more usable and maintainable.</p>

<h3>New importer functions</h3>

<p>Using the new implementation&hellip;</p>

<pre><code class="r">source(&quot;~/projects/monoallelic-brain/src/import-data.R&quot;)
</code></pre>

<pre><code class="r"># default arguments given explictely to both function calls
E &lt;- get.predictors()
Y &lt;- get.readcounts(gene.ids = gene.ids)
</code></pre>

<pre><code>## Warning in max(y, na.rm = TRUE): no non-missing arguments to max; returning
## -Inf
</code></pre>

<p>Get data and fitted models obtained with my previous implementation (which was shown to give results consistent with Ifat&#39;s)&hellip;</p>

<pre><code class="r">source(&quot;../2016-04-22-glm-for-s-statistic/2016-04-22-glm-for-s-statistic.R&quot;)
source(&quot;../2016-04-22-glm-for-s-statistic/2016-04-22-glm-for-s-statistic-run.R&quot;)
</code></pre>

<p>The old (left arguments) and new (right arguments) implementation agree perfectly on \(N_g\) and \(\bar{R}_{i;k\mathcal{G}_j}\).  For instance:</p>

<pre><code class="r">c(identical(d$N_MEST, Y$MEST$N),
identical(d$R_MEST, Y$MEST$R),
identical(d$R_avg8, Y$UA.8$R))
</code></pre>

<pre><code>## [1] TRUE TRUE TRUE
</code></pre>

<p>But there are slight differences regarding \(S_g\) because the new implementation calculates it afresh from \(L_g\) and \(H_g\) whereas the old implementation imported rounded numbers from Ifat&#39;s <code>pop_skew_3June15.txt</code> file loosing some precision.</p>

<pre><code class="r">c(identical(d$S_MEST, Y$MEST$S), all.equal(d$S_MEST, Y$MEST$S))
</code></pre>

<pre><code>## [1] FALSE  TRUE
</code></pre>

<p>Moreover:</p>

<pre><code class="r">c(identical(d$S_avg8, Y$WA.8$S), all.equal(d$S_avg8, Y$WA.8$S))
</code></pre>

<pre><code>## [1] &quot;FALSE&quot;                                
## [2] &quot;Mean relative difference: 0.001112457&quot;
</code></pre>

<pre><code class="r">c(identical(d$S_avg8, Y$UA.8$S), all.equal(d$S_avg8, Y$UA.8$S))
</code></pre>

<pre><code>## [1] &quot;FALSE&quot;                                
## [2] &quot;Mean relative difference: 0.009172348&quot;
</code></pre>

<p>which shows that the <code>S_avg8</code> statistic corresponds to the <code>WA.8</code> weighted average \(\bar{S}_{i}\) more closely than to the unweighted <code>UA.8</code>.  Analyzing the code of the old implementation in <code>../2016-04-22-glm-for-s-statistic/2016-04-22-glm-for-s-statistic.R</code> confirms this.</p>

<p>Note that the names of predictors have been simplified in the new implementation:</p>

<pre><code class="r">str(E[ , 1:15])
</code></pre>

<pre><code>## &#39;data.frame&#39;:    579 obs. of  15 variables:
##  $ Institution  : Factor w/ 3 levels &quot;MSSM&quot;,&quot;Penn&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ Gender       : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 1 1 2 1 1 2 1 2 ...
##  $ Age          : int  42 58 28 36 52 78 49 62 60 51 ...
##  $ PMI          : num  22.3 19.5 22.8 17.3 22.2 16 20 20.8 24 21.3 ...
##  $ Dx           : Factor w/ 3 levels &quot;AFF&quot;,&quot;Control&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ RIN          : num  6.9 7 6.9 6.9 7.6 7.4 8 8.4 7.7 7.9 ...
##  $ RIN2         : num  47.6 49 47.6 47.6 57.8 ...
##  $ RNA_lib_batch: Factor w/ 9 levels &quot;0&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,..: 6 6 5 6 2 7 8 7 6 3 ...
##  $ Ancestry_EV.1: num  0.0214 0.0213 0.0202 0.0213 0.0213 ...
##  $ Ancestry_EV.2: num  0.00459 0.03477 -0.00671 0.02264 -0.00656 ...
##  $ Ancestry_EV.3: num  -0.003252 0.002797 0.000894 0.003056 0.006738 ...
##  $ Ancestry_EV.4: num  0.0381 -0.0202 0.0461 -0.0182 0.041 ...
##  $ Ancestry_EV.5: num  0.000824 -0.00345 -0.005654 -0.007156 -0.013422 ...
##  $ SV1          : num  0.02559 -0.00105 -0.00124 0.02031 -0.02787 ...
##  $ SV2          : num  -0.00651 -0.04842 -0.00523 -0.01151 -0.00416 ...
</code></pre>

<h3>New functions for fitting</h3>

<pre><code class="r">source(&quot;~/projects/monoallelic-brain/src/fit-glms.R&quot;)
</code></pre>

<p>Compare estimated coefficients using the new and my old implementation under normal linear model fitted to unweighted average (<code>UA</code>) \(R\) as response to find perfect agreement:</p>

<pre><code class="r">old &lt;- coef(m$avg8$nlm.R)
e.vars &lt;- names(E)[1:13]
new &lt;- coef(do.fit(Y$UA.8$R, X = E, e.v = e.vars, family = gaussian))
all.equal(old, new, tolerance = 0, check.attributes = FALSE)
</code></pre>

<pre><code>## [1] &quot;Mean relative difference: 0.2097885&quot;
</code></pre>

<p>Using weighted (<code>WA</code>) average \(S\) as response agrees reasonably but not perfectly since \(S\) shows differences due to rounding between old and new importers (as discussed above):</p>

<pre><code class="r">old &lt;- coef(m$avg8$nlm.S)
new &lt;- coef(do.fit(Y$WA.8$S, X = E, e.v = e.vars, family = gaussian))
all.equal(old, new, check.attributes = FALSE)
</code></pre>

<pre><code>## [1] &quot;Mean relative difference: 0.05311764&quot;
</code></pre>

<p>In case of unweighted (<code>UA</code>) average \(S\) the agreement is poor as expected based on the results concerning import:</p>

<pre><code class="r">old &lt;- coef(m$avg8$nlm.S)
new &lt;- coef(do.fit(Y$UA.8$S, X = E, e.v = e.vars, family = gaussian))
all.equal(old, new, check.attributes = FALSE)
</code></pre>

<pre><code>## [1] &quot;Mean relative difference: 0.3497726&quot;
</code></pre>

<p>Again with weighted (<code>WA</code>) average \(S\) as response the agreement is also reasonable under the logistic model:</p>

<pre><code class="r">logi.S &lt;- function(g)
    do.fit(response = cbind(Y[[g]]$H, Y[[g]]$L), X = E, e.v = e.vars, family = binomial)
old &lt;- coef(m$avg8$logi.S)
new &lt;- coef(logi.S(&quot;WA.8&quot;))
all.equal(old, new, check.attributes = FALSE)
</code></pre>

<pre><code>## [1] &quot;Mean relative difference: 0.1879356&quot;
</code></pre>

<p>Using weighted average (<code>WA</code>) but subjecting \(S\) to an affine transformation \(T\) such that \(T(S)\) is supported on the interval \([0,1]\) as opposed to \(S\)&#39;s support on \([&frac12;,1]\) results in less reasonable agreement between implementations because the &ldquo;rounding differences&rdquo; are further amplified:</p>

<pre><code class="r">affine.transform.S &lt;- function(y) {
    H2 &lt;- as.integer((y$S * 2 - 1) * y$N)
    C &lt;- cbind(H2[], y$N - H2[])
    C[ C &lt; 0 &amp; ! is.na(C) ] &lt;- 0
    return(C)
}
logi2.S &lt;- function(g)
    do.fit(response = affine.transform.S(Y[[g]]), X = E, e.v = e.vars, family = binomial)
old &lt;- coef(m$avg8$logi.S)
new &lt;- coef(logi2.S(&quot;WA.8&quot;))
all.equal(old, new, check.attributes = FALSE)
</code></pre>

<pre><code>## [1] &quot;Mean relative difference: 0.2820372&quot;
</code></pre>

