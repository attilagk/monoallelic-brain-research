## Introduction

ANOVA and effects were used before...TODO

The least square estimates are given by $\hat{\beta} = (X^T X)^{-1} X^T y$.  Permuting the coefficients is equivalent to permuting the bases of the linear transformation $(X^T X)^{-1} X^T$ or, equivalently, permuting the *rows* of the corresponding matrix or, equivalently again, permuting the *columns* of the design matrix.  Therefore, when explanatory variables are reordered and the columns of the design matrix are permuted accordingly then the least square estimates still remain the same up to their relative order.

Take two permutations of explanatory variables:

1. **forward** has been used in all my and Ifat's previous analysis
2. the **reverse** of the above


## Preparation

Relevant scripts
```{r echo=FALSE}
library(lattice)
library(latticeExtra)
opts_chunk$set(dpi = 144)
opts_chunk$set(out.height = "700px")
opts_chunk$set(dev = c("png", "pdf"))
lattice.options(default.args = list(as.table = TRUE))
lattice.options(default.theme = "standard.theme")
source("~/projects/monoallelic-brain/src/import-data.R")
source("~/projects/monoallelic-brain/src/fit-glms.R")
```

Import data; note that the set of **selected genes have been updated** based on later analysis
```{r cache=TRUE, warning=FALSE}
E <- get.predictors() # default arguments
# updated gene set
gene.ids <- unlist(read.csv("../../data/genes.regression.new", as.is = TRUE))
names(gene.ids) <- gene.ids
Y <- get.readcounts(gene.ids = gene.ids, count.thrs = 0)
#nobs <- as.data.frame(lapply(list(unfiltered=Y, filtered=Y.f), function(y) sapply(y, function(x) sum(! is.na(x[[1]])))))
```

Fit both `wnlm.R` and `logi.S` using both the forward and the reverse order permutation.
```{r cache=TRUE, warning=FALSE}
# e.vars defined in fit-glms.R
e.v <- list(forward = e.vars, reverse = rev(e.vars), custom = names(E)[1:13])
# exclude unweighed aggregates UA.8 and UA from fitting
to.fit.ids <- grep("^UA(.8)?$", names(Y), value = TRUE, invert = TRUE)
M <- lapply(list(wnlm.R = "wnlm.R", logi.S = "logi.S"),
            function(m) lapply(e.v,
                               function(v) do.all.fits(Y[to.fit.ids], preds = v, sel.models = m)[[1]]))
# a list of (sub)lists mirrioring the structure of M (sublists: forward or reverse)
f.ids <- lapply(M, lapply, function(m) ! sapply(m, is.null))
# the fit for TMEM261P1 has not converged under logi.S
f.ids$logi.S$forward["TMEM261P1"] <- FALSE
f.ids$logi.S$reverse["TMEM261P1"] <- FALSE
```

Consistent with the theory above, wherever the fit converged (with the exception of TMEM261P1), the order has no impact on the regression coefficients.  The next `R` expression compares coefficient estimates between forward and reverse under `logi.S` for every gene or aggregate and reports any difference:
```{r}
grep("TRUE", sapply(to.fit.ids, function(g) all.equal(coef(M$logi.S$forward[[g]]), coef(M$logi.S$reverse[[g]])[ names(coef(M$logi.S$forward[[g]])) ])), invert = TRUE, value = TRUE)
```

## Components of variation

ANOVA allows *direct* comparison of predictors (explanatory variables) by partitioning all explained/systematic variation in the response ($S$ or $R$) among them.  Similarly, the directly comparable effect of each of the $p$ regression coefficients on the response (an $n$-vector) can be obtained from QR decomposition of the response into a set of $n$ orthogonal vectors, in which a subset of $p$ vectors corresponds to the coefficients. 

In the above sentences "directly comparable" means that the effects are on a uniform scale for all predictors/coefficients for a given gene as that scale is closely related to the one on which the response varies.  But the total variation of the response $S$ itself shows variation across genes, which leaves two options in gene-gene comparisons: compare components of variation with or without correction for across gene variation of the total variance.  The first one will be referred below as **genes on uniform scale** and the second as **genes on relative scale**.

### Comparing predictors with genes on uniform scale

```{r cache=TRUE, warning=FALSE}
A.long <- lapply(lapply(M, lapply, l.anova), reshape.2, type = "anova")
```

```{r lattice-functions, warning=FALSE, echo=FALSE}

my.stripplot <- function(fm = Predictor ~ Deviance | Order, data = A.long$logi.S, ...) {
    stripplot(fm,
              groups = Gene,
              data = data,
              subset = Order %in% c("forward", "reverse"),
              jitter.data = TRUE, fun = identity, type = "p",
              pch = 21, abline = list(v = 0, col = "gray"),
              grid = TRUE,
              #auto.key = TRUE,
              panel = function(x, y, ...) {
                  panel.bwplot(x, y, do.out = FALSE, ...)
                  panel.stripplot(x, y, ...)
              }, ...)
}

my.dotplot <- function(fm = Predictor ~ Deviance | Gene, data = A.long$logi.S, ...) {
    dotplot(fm,
              groups = Order,
              data = data,
              subset = Order %in% c("forward", "reverse"),
              abline = list(v = 0, lty = 2),
              #scales = list(x = "free"),
              auto.key = list(text = levels(data$Order)[1:2], columns = 2),
              layout = c(8, 4),
              between = list(x = 0.2),
              par.settings = list(superpose.symbol = list(pch = 21, alpha = 0.5)),
              ...)
}
```

Under `logi.S`:
```{r anova-fw-rv-logi.S, echo=FALSE, cache=TRUE}
(plots <- list(anova.logi.S = my.stripplot(fm = Predictor ~ Deviance | Order, data = A.long$logi.S, main = "ANOVA under logi.S")))
```

The same tendencies emerge under `wnlm.R`:
```{r anova-fw-rv-wnlm.R, echo=FALSE}
(plots$anova.wnlm.R <- my.stripplot(fm = Predictor ~ Deviance | Order, data = A.long$wnlm.R, main = "ANOVA under wnlm.R"))
```

```{r cache=TRUE, warning=FALSE}
Ef.long <- lapply(M, function(m) { x <- l.l.effects(m); x <- x[ ! x$Coefficient %in% "(Intercept)", ] })
```

Under `logi.S`:
```{r effects-fw-rv-logi.S, echo=FALSE}
(plots$effects.logi.S <- my.stripplot(fm = Coefficient ~ Effect | Order, data = Ef.long$logi.S, main = "Effects under logi.S"))
```

Again, similar tendencies are observed under `wnlm.R`:
```{r effects-fw-rv-wnlm.R, echo=FALSE}
(plots$effects.wnlm.R <- my.stripplot(fm = Coefficient ~ Effect | Order, data = Ef.long$wnlm.R, main = "Effects under wnlm.R"))
```

### Figure for manuscript

```{r anova-effects-fw-rv-logi.S, echo=FALSE, fig.asp=2.0, fig.width=3.5}
print(update(plots$anova.logi.S, main = "", layout = c(2, 1)), split = c(1, 1, 1, 2), more = TRUE)
print(update(plots$effects.logi.S, main = "", layout = c(2, 1)), split = c(1, 2, 1, 2), more = FALSE)
```

### Comparison with genes on relative scale

```{r anova-fw-rv-logi.S-trellis, echo=FALSE, fig.asp=1}
my.dotplot(fm = Predictor ~ Deviance | Gene, data = A.long$logi.S, main = "ANOVA under logi.S", scales = list(x = "free"))
```

```{r effects-fw-rv-logi.S-trellis, echo=FALSE, fig.asp=1.4}
my.dotplot(fm = Coefficient ~ Effect | Gene, data = Ef.long$logi.S, main = "Effects under logi.S", scales = list(x = "free"))
```

```{r anova-fw-rv-wnlm.R-trellis, echo=FALSE, fig.asp=1}
my.dotplot(fm = Predictor ~ Deviance | Gene, data = A.long$wnlm.R, main = "ANOVA under wnlm.R", scales = list(x = "free"))
```

```{r effects-fw-rv-wnlm.R-trellis, echo=FALSE, fig.asp=1.4}
my.dotplot(fm = Coefficient ~ Effect | Gene, data = Ef.long$wnlm.R, main = "Effects under wnlm.R", scales = list(x = "free"))
```

### Another view, genes on uniform scale

This display is meant to be comparable to a similarly structured trellis display of estimated regression coefficients.

```{r cache=TRUE, warning=FALSE, message=FALSE, fig.asp=1}
Betas <- lapply(M, function(m) { x <- get.estimate.CI(m$forward); x <- x[ ! x$Coefficient %in% "(Intercept)", ] })
```

#### Under logi.S

```{r warning=FALSE, echo=FALSE, message=FALSE, fig.asp=1.7}
my.segplot <- function(data = Betas$logi.S,
                       main = expression(paste("99 % CI for ", beta, " under logi.S")),
                       ...) {
    segplot(Gene ~ Lower.CL + Upper.CL | Coefficient,
            data = data,
            scales = list(x = list(relation = "free")),
            layout = c(6,4),
            between = list(x = 0.2),
            panel = function(x, y, ...) {
                panel.grid(h = -1, v = 0)
                panel.segplot(x, y, ...)
                panel.abline(v = 0, col = "red")
            },
            main = main, as.table = TRUE, center = Estimate, draw.bands = FALSE, ...)
}
```

```{r effects-fw-rv-logi.S-trellis-coef-cond, fig.asp=1.7}
# conditioning on the Coefficient instead of Gene
my.dotplot(fm = Gene ~ Effect | Coefficient, data = Ef.long$logi.S, main = "Effects under logi.S")
```

```{r reg-coef-logi.S, dev=c("png", "pdf"), fig.width=10, fig.asp=1.7}
my.segplot(data = Betas$logi.S)
```

#### Under wnlm.R

```{r effects-fw-rv-wnlm.R-trellis-coef-cond, fig.asp=1.7}
# conditioning on the Coefficient instead of Gene
my.dotplot(fm = Gene ~ Effect | Coefficient, data = Ef.long$wnlm.R, main = "Effects under wnlm.R")
```

```{r reg-coef-wnlm.R, dev=c("png", "pdf"), fig.width=10, fig.asp=1.7}
my.segplot(data = Betas$wnlm.R, main = expression(paste("99 % CI for ", beta, " under wnlm.R")))
```
