## Preparations

```{r echo=FALSE, warnings=FALSE}
library(ggplot2)
library(lattice)
library(latticeExtra)
opts_chunk$set(dpi = 144)
opts_chunk$set(out.width = "700px")
opts_chunk$set(dev = c("png", "pdf"))
lattice.options(default.args = list(as.table = TRUE))
lattice.options(default.theme = "standard.theme")
```

Load functions

```{r}
source("~/projects/monoallelic-brain/src/import-data.R")
source("~/projects/monoallelic-brain/src/fit-glms.R")
source("~/projects/monoallelic-brain/src/graphics.R")
```

```{r}
gene.ids <- unlist(read.csv("../../data/genes.regression.new", as.is = TRUE))
names(gene.ids) <- gene.ids
names(e.vars) <- e.vars
```

```{r cache=TRUE, warning=FALSE}
E <- get.predictors() # default arguments
Y <- get.readcounts(gene.ids = gene.ids, count.thrs = 0)
```

```{r cache=TRUE, warning=FALSE, message=FALSE}
set.seed(1976)
perms <- data.frame(cbind(seq_len(nrow(E)), replicate(n.perm <- 1e4, sample.int(nrow(E)))))
names(perms) <- c("U", paste0("P", seq_len(n.perm)))
sel.models <- c("wnlm.Q", "logi.S")
sel.vars <- e.vars[c(1, 3, 5, 8)]
system.time(Betas <- aggregate.CI.permut2(perms = perms, gene.ids = gene.ids, e.vars = e.vars,
                                          sel.vars = sel.vars, sel.models = sel.models,
                                          E = E, Y = Y[gene.ids], skip.CI = TRUE))
```

## Results

The expressions above obtain the null distribution of regression coefficients for the selected predictor(s) `r sel.vars` under the selected model(s) `r sel.models` based on `r n.perm` permutations.  Each panel within a plot shows a red vertical zero line of the null hypothesis $\beta_j = 0$, the null distribution as probability density (solid blue line) based on the permutations, and the corresponding p-value (dotted blue line and number on the bottom).

### Under wnlm.Q

```{r beta-age-null-wnlm-Q}
beta0densityplot("Age", mtype = "wnlm.Q")
```

```{r beta-gender-null-wnlm-Q, echo=FALSE}
beta0densityplot("GenderMale", mtype = "wnlm.Q")
```

```{r beta-dx-scz-wnlm-Q, echo=FALSE}
beta0densityplot("DxSCZ", mtype = "wnlm.Q")
```

```{r beta-dx-aff-wnlm-Q, echo=FALSE}
beta0densityplot("DxAFF", mtype = "wnlm.Q")
```

```{r beta-ancestry-1-null-wnlm-Q, echo=FALSE}
beta0densityplot("Ancestry.1", mtype = "wnlm.Q")
```

### Under logi.S

```{r beta-age-null-logi-S, echo=FALSE}
beta0densityplot("Age", mtype = "logi.S")
```

```{r beta-gender-null-logi-S, echo=FALSE}
beta0densityplot("GenderMale", mtype = "logi.S")
```

```{r beta-dx-scz-logi-S, echo=FALSE}
beta0densityplot("DxSCZ", mtype = "logi.S")
```

```{r beta-dx-aff-logi-S, echo=FALSE}
beta0densityplot("DxAFF", mtype = "logi.S")
```

```{r beta-ancestry-1-null-logi-S, echo=FALSE}
beta0densityplot("Ancestry.1", mtype = "logi.S")
```

## Comparison to p-values from t-distribution

The calculations and the plot below compare the p-values from the permutations to those based on the theoretical t-distribution of the statistic.  Comparing these results to those from model checking reveals that the two approaches to p-value calculation agree (fall near the gray diagonal on the plots) as long as the model fits the data well.  Otherwise the t-distribution based approach tends to produce much lower p-values and therefore exaggerate the significance that $\beta_j\neq 0$.

```{r}
source("2016-10-03-permutation-test.R")
```

```{r cache=TRUE, warning=FALSE}
M <- do.all.fits(Z = Y[gene.ids], G = E, preds = e.vars, sel.models = sel.models)
cf <- unlist(sapply(e.vars, function(e.v) predictor2coefs(M[[c(1, 1)]], e.v)))
both.p.val <-
    do.call(rbind,
            lapply(sel.models, function(mtype)
                   do.call(rbind,
                           lapply(cf, function(coef)
                                  do.call(rbind,
                                          lapply(gene.ids,
                                                 function(g) get.both.p.vals(mtype = mtype, gene = g, coef = coef, M = M, B = Betas)))))))
```

```{r p-val-tdist-vs-perm, echo=FALSE}
xyplot(- log10(p.val.t.dist) ~ - log10(p.val.perm) | Gene, data = both.p.val, groups = Model,
       par.settings = list(add.text = list(cex = 0.8)),
       panel = function(...) {
           panel.abline(a = 0, b = 1, col = "gray", lty = "dotted")
           panel.xyplot(...)
       },
       auto.key = list(columns = 2),
       xlab = expression(paste(plain(-log)[10], "p  (permutations)")),
       ylab = expression(paste(plain(-log)[10], "p  (t-distribution)")),
       ylim = c(-1, 15))
```

### Filtering for poor fit

This filtering is based on earlier decisions on the goodness of fit of logi.S, which is stored in `results/model-checking.csv`.

```{r}
both.p.val <- cbind(both.p.val, read.csv("../../results/model-checking.csv", row.names = "gene")["logi.S.fit.OK"])
# set results to NA where logi.S fitted poorly
both.p.val[with(both.p.val, Model == "logi.S" & logi.S.fit.OK == FALSE), c("Estimate", "p.val.t.dist", "p.val.perm")] <- NA
```

Figure for manuscript showing p-values calculated from both approaches (theory: t-distribution, and permutation test) and under both models (wnlm.Q and, when the fit was OK, also logi.S)

```{r p-values, echo=FALSE}
p.val.plot <-
    with(both.p.val,
         xyplot(- log10(p.val.t.dist) ~ - log10(p.val.perm) | Coefficient * Model, data = both.p.val, groups = Gene,
                subset = Coefficient %in% c("Age", "GenderMale", "Ancestry.1", "DxSCZ"),
                par.settings = list(add.text = list(cex = 0.8),
                                    superpose.symbol =
                                        list(fill = rainbow(n = length(levels(Gene)), start = 0, end = 5 / 6))),
                gene = as.character(as.integer(Gene)), estimate = Estimate, model = Model,
                panel = function(x, y, groups, subscripts, gene, estimate, ...){
                    sig.lev <- c(-log10(5e-2), 2, 3)
                    panel.abline(v = sig.lev , h = sig.lev, col = "gray")
                    panel.abline(a = 0, b = 1, col = "gray", lty = "dotted")
                    col <- trellis.par.get("superpose.symbol")$fill
                    panel.xyplot(x, y, pch = 21, fill = col, col = col, cex = 1.5, alpha = 0.5)
                    panel.text(x, y, labels = gene[subscripts], cex = 0.7, ...)
                },
                auto.key = list(columns = 5, cex = 0.7, points = FALSE,
                                text = paste0("(", seq_along(levels(Gene)), ") ", levels(Gene))),
                aspect = 1, scales = list(relation = "same"),
                xlab = expression(paste(plain(-log)[10], "p  (permutations)")),
                ylab = expression(paste(plain(-log)[10], "p  (t-distribution)"))))
useOuterStrips(p.val.plot)
```

## Saving results

Writing long format results:

```{r}
write.csv(both.p.val, "../../results/regr-coefs.csv", row.names = FALSE)
```

```{r}
v.names <- c("Estimate", "p.val.t.dist", "p.val.perm")
mtypes <- c("wnlm.Q", "logi.S")
varying <- lapply(c(v.names), function(v) sapply(mtypes, function(m) paste0(v, ".", m)))
both.p.val.w <-
    reshape(both.p.val, direction = "wide", varying = varying, v.names = v.names,
            timevar = "Model", times = mtypes, idvar = c("Gene", "Coefficient"))
stars <- data.frame(sapply(varying.p <- unlist(varying[-1])[c(1, 3, 2, 4)],
                           function(v) annotate.signif(both.p.val.w[[v]])))
names(stars) <- paste0(varying.p, ".*")
both.p.val.w <- cbind(both.p.val.w[2:1], stars, both.p.val.w[-1 * 2:1])
write.csv(both.p.val.w, "../../results/regr-coefs-w.csv", row.names = FALSE)
```
