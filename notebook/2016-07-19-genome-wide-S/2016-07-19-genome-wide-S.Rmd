### Missing data due to bug

For each gene $g$ of 16026 genes the higher and lower read counts across $I_g\le 579$ individuals $\{H_{ig}, L_{ig} \,|\, i=1,...,I_g\}$ are stored in a `.csv` file.  However, nearly 3 % of those files are empty due to a bug that resulted in multiple headers in [Ifat's html tables][ifat] (see for instance gene AK3) and to the inability of my converter script to deal with such tables.  To see this:

```{r engine="bash"}
DATADIR="../../data/readcount/"
SEDCMD='s/^.*attila attila\s\+\([[:digit:]]\+\).*\/\([^/]\+\)\.csv$/\1,\2/'
OUTFILE="${DATADIR}/fsize-genes.csv"
[ -f $OUTFILE ] || {
    # create header
    echo "file.size,gene.symbol" > $OUTFILE
    # get file size (in bytes) for each gene under 'genes' directory
    find "${DATADIR}/genes" -name '*.csv' | xargs ls -l | sed "$SEDCMD" >> $OUTFILE
}
cat <<EOF
Number of .csv files

all: $(grep --count '^[[:digit:]]\+,' $OUTFILE )
empty: $(grep --count '^0,' $OUTFILE )
EOF
```

```{r echo=FALSE}
library(lattice)
library(latticeExtra)
opts_chunk$set(dpi = 144)
opts_chunk$set(fig.width = 10)
opts_chunk$set(dev=c("png", "pdf"))
lattice.options(default.args = list(as.table = TRUE))
lattice.options(default.theme = "standard.theme")
lattice.options(skip.boundary.labels = 0)
```

### Import read count data

Load data importer functions:
```{r}
source("../../src/import-data.R")
source("../../src/utils.R")
source("2016-07-19-genome-wide-S.R")
```

The following expressions import $S_{ig}$ for all `r 16026 - 442` genes for which the csv file is nonempty.

```{r cache=TRUE}
gene.summary <-
    read.csv("../../data/readcount/summary-all-genes.csv")
rownames(gene.summary) <- gene.summary$Symbol
gene.summary$file.size <-
    read.csv("../../data/readcount/fsize-genes.csv", row.names = 2)[rownames(gene.summary), , drop = TRUE]
gene.ids <- with(gene.summary, as.character(Symbol)[ file.size > 0 ])
```

```{r genomwide-data-import, cache=TRUE, warning=FALSE}
Y <- get.readcounts(gene.ids, g.subsets = list(), sel.var = c("H", "N"))
S <- data.frame(lapply(gene.ids, function(g) Y[[g]]$H / Y[[g]]$N), check.names = FALSE)
names(S) <- gene.ids
N <- data.frame(lapply(Y, getElement, "N"), check.names = FALSE)
rm(Y)
```

### Filtering genes based on number of observations

For more than half of even the genes $g$ with nonempty files the number $I_g$ of observations (the number of individuals/RNA samples with read count data on $g$) is zero.  In what follows, not only these genes are filtered out but also those with less than 10 observations, indicated by the vertical dashed line on the empirical ECDF plot below.

```{r}
min.n.obs <- 10
```
```{r ecdf-n-obs, echo=FALSE, fig.width=7, fig.asp=2/3}
ecdfplot(sapply(S, function(y) sum(! is.na(y))), type = c("l", "g"),
         panel = function(...) {
             panel.ecdfplot(...)
             panel.abline(v = min.n.obs, lty = 2)
         }, xlab = "number of observations on gene",
         main = paste0("Read count availability (", as.character(ncol(S)), " genes)"))
```

### Data preparation

Computationally demanding calculations to prepare data for presentation:

```{r genomwide-data-shaping, cache=TRUE, warning=FALSE}
# filter genes given the minimum number of allowed observations 'min.n.obs'
ok.genes <- names(S)[sapply(S, function(y) sum(! is.na(y)) >= min.n.obs)]
# obtain the ECDF of S_ig for all given genes g
ED <- emp.distr.S(S[ , ok.genes],
                  ss = seq(from = 0.5, to = 1, length.out = 101),
                  with.density = TRUE)
# order genes according to the value of the ECDF at 0.9
gene.order <- order(sapply(ED[[1]], function(f) f(0.9)))
ecdf.val.w <- ED$ecdf.val[ , gene.order]
density.w <- ED$density[ , gene.order]
ED.long <- reshape(ecdf.val.w, v.names = "ECDF", varying = names(ecdf.val.w),
                   timevar = "gene", times = factor(names(ecdf.val.w)),
                   idvar = "s", ids = ED$ss, direction = "long")
density.long <- reshape(density.w, v.names = "density", varying = names(density.w),
                   timevar = "gene", times = factor(names(density.w)),
                   idvar = "s", ids = ED$ss, direction = "long")
ED.long$density <- density.long$density
ED.long$gene <- factor(ED.long$gene, levels = names(ecdf.val.w), ordered = TRUE)
rm(list = c("ecdf.val.w", "density.w", "density.long"))
```

```{r genomwide-data-shaping-incorrect, cache=TRUE, warning=FALSE, echo=FALSE}
ED.long.old <- reshape(ED$ecdf.val, v.names = "ECDF", varying = names(ED$ecdf.val),
                   timevar = "gene", times = factor(names(ED$ecdf.val)),
                   idvar = "s", ids = ED$ss, direction = "long")
ED.long.old$density <- reshape(ED$density, v.names = "density", varying = names(ED$density),
                   timevar = "gene", times = factor(names(ED$density)),
                   idvar = "s", ids = ED$ss, direction = "long")$density
ED.long.old$gene <- factor(ED.long.old$gene, levels = names(ED$ecdf.val), ordered = TRUE)
```

```{r frequencies-for-classes, cache=TRUE, warning=FALSE}
sorted.genes <- ok.genes[gene.order]
names(sorted.genes) <- sorted.genes
cum.fraction <- data.frame(lapply(ED$ecdf[sorted.genes], function(f) f(10:6 / 10)), check.names = FALSE)
row.names(cum.fraction) <- as.character(10:6 / 10)
andys.test <-
    data.frame(lapply(sorted.genes,
                      function(g)
                          sum(S[[g]] <= 0.6 & CI.p(S[[g]], N[[g]])$upper < 0.7, na.rm = TRUE) / sum(! is.na(S[[g]]))),
               check.names = FALSE)
row.names(andys.test) <- "andys.test"
cum.fraction <- rbind(cum.fraction, andys.test)
rm(andys.test)
fraction <- data.frame(lapply(cum.fraction, function(y) - diff(c(y, 0))), check.names = FALSE)
row.names(fraction) <- row.names(cum.fraction)
```

### Figure for manuscript

This figure is intended to:

* present a few representative genes characterized by the parental "imbalance score" $S$ statistic (two upper graphs)
  * e.g. PEG10 and ZNF331 represent monoallelic expression and AFAP1 biallelic expression
  1. density est.: kernel density estimates, whose interpretation is identical to that of histograms
  1. ECDF: empirical cumulative distribution function, sometimes called cumulative fraction
* present a compact genome-wide overview of parental imbalance (lower left graph)
  * imbalance is expressed in terms of the ECDF of $S$ using a color scheme, introduced in the upper 2nd and 3rd graphs
  * the thousands of genes are ranked from the most imbalanced (monoallelic, top) to the most balanced (biallelic, bottom)
  * the ranking is based on the ECDF evaluated at $s = 0.9$, as shown in the upper 2nd graph and the bottom right plots
* support the conclusion that $\approx 1 \%$ of all genes are appreciably imbalanced (monoallelically expressed)

```{r complex-plot, echo=FALSE, fig.width=7, fig.aspect=1.5}
sel.g <- c("PEG10", "ZNF331", "AFAP1")
S.long <- reshape.Y(Y = S, sel.g = sel.g)
plots <- list()
superpose.line <- standard.theme(color = FALSE)$superpose.line
superpose.line$lty <- c(2, 1, 3:7)
plots$density <- my.densityplot(S.long, par.settings = list(superpose.line = superpose.line))
plots$ecdf <- my.ecdfplot(S.long, eval.at = c(0.9), par.settings =
                          list(superpose.line = superpose.line,
                               plot.symbol = list(pch = 21, col = "black", cex = 1, fill = "lightgray")))
plots$level <- my.levelplot(ED.long, pct.top.g = 2, n.all.g = length(ok.genes), top.on.top = TRUE)
plots$level.sel.g <- my.levelplot.sel.g(ED.long, sel.g = sel.g, letter.labels = TRUE)
plots$rank <- rankplot(cum.fraction, plot.andys.test = FALSE, pct.top.g = 2, sel.g = sel.g, top.on.top = TRUE,
                       par.settings = list(superpose.symbol =
                                           list(pch = c(20, 21, 21)[-1], col = c("gray", "black", "black")[-1],
                                                alpha = c(0.5, 0.5, 1)[-1], cex = c(0.1, 0.5, 1)[-1], fill = "lightgray")))
# print to complex layout
plot.all(plots)
```

### Fixed ranking bug

An earlier version of the above figure had incorrect ranking.  The figure compares that to the present, correct, ranking:

```{r fixed-ranking, echo=FALSE, fig.width=7}
plot(my.levelplot(ED.long, main = "Correct ranking"), split = c(1, 1, 2, 1), more = TRUE)
plot(my.levelplot(ED.long.old, main = "Incorrect ranking"), split = c(2, 1, 2, 1), more = FALSE)
```

### Another view on ranked genes

```{r rank-by-ecdf-top, echo=FALSE, fig.width=7, fig.aspect=2}
#ecdf.at.some.s(ED = ED, sel.g = ok.genes[gene.order[seq_len(50)]], ylab = "gene rank")
trellis.par.set(superpose.polygon = list(lty = 0))
xlab <- "fraction of indiv."
plot(barchart(t(as.matrix(fraction[rev(sorted.genes[1:100])])), par.settings = list(superpose.polygon = list(col = palette.ifat(detailed = FALSE))), main = "Top 100 genes", xlab = xlab), split = c(1, 1, 2, 1), more = TRUE)
plot(barchart(t(as.matrix(fraction[rev(sorted.genes)])), par.settings = list(superpose.polygon = list(col = palette.ifat(detailed = FALSE))), scales = list(y = list(at = y.lab <- seq(0, length(sorted.genes), by = 1000), label = as.character(rev(y.lab)))), main = "All genes", xlab = xlab), split = c(2, 1, 2, 1), more = FALSE, box.width = 1)
```


[ifat]: http://katahdin.mssm.edu/ifat/web/cm/home
[Fig 1]: https://docs.google.com/presentation/d/1YvpA1AJ-zzir1Iw0F25tO9x8gkSAzqaO4fjB7K3zBhE/edit#slide=id.p4
