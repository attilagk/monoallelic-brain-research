<h2>Preparing data for analysis in <code>R</code></h2>

<h3>Read counts from Ifat&#39;s website</h3>

<p>The source of read count data is the largest HTML table generated dynamically using the <code>All genes</code> option in <a href="http://katahdin.mssm.edu/ifat/web/cm/get_pop_freq.pl">Ifat&#39;s website</a>.  The output is a <code>csv</code> file for each gene within a gene-specific subdirectory.  Due to the specifics of Ifat&#39;s html tables and the general difficulty of the <code>html</code> to <code>csv</code> conversion only the &ldquo;higher&rdquo; and &ldquo;lower&rdquo; read counts could be formatted in a usable way; the underlying <strong>SNP-specific read counts could not be retrieved</strong> in a clean way.  The same holds for the corresponding genotypes.</p>

<pre><code class="bash"># directories
PDIR=$HOME/projects/monoallelic-brain # project directory
RCDIR=$PDIR/data/readcount/ # directory for readcounts
OUTDIR=$RCDIR/genes # subdir for gene-wise readcount

# data files
SUMMARYHTML=$RCDIR/summary-all-genes.html # should already exist
SUMMARYCSV=$RCDIR/summary-all-genes.csv # will be created

# script files
SCRIPT1=$PDIR/src/summary-html2csv
SCRIPT2=$PDIR/src/all-genes-readcounts-for-R 

# run scripts
test -f $SUMMARYHTML || exit 1
test -f $SUMMARYCSV || $SCRIPT1 $SUMMARYHTML &gt; $SUMMARYCSV
test -d $OUTDIR || $SCRIPT2 $SUMMARYCSV 2&gt; /dev/null
echo &quot;number of gene-wise read count datasets:&quot;
find $OUTDIR -type d | wc -l
echo &quot;total size:&quot;
du -sh $OUTDIR

</code></pre>

<pre><code>## number of gene-wise read count datasets:
## 16027
## total size:
## 1.4G /home/attila/projects/monoallelic-brain/data/readcount//genes
</code></pre>

<h3>Predictors</h3>

<p>The data on predictors (explanatory variables, which can be either covariates or factors) was sent to me by Andy as email attached files.  The following code produces two files: <code>predictors.csv</code> is the main data table whereas <code>RNAseq_ID.DLPFC_RNA_ID.csv</code> is a mapping between RNAseqID (present in read count tables) and DLPFC_RNA_ID (present in the table of predictors).  Putting together those two is much easier in <code>R</code> than in shell scripts.</p>

<pre><code class="bash"># directories
PDIR=$HOME/projects/monoallelic-brain # project directory
INDIR=$PDIR/data/ifat/age-dependence # input directory
OUTDIR=$PDIR/data/predictors/ # output directory

# input files from Ifat via Andy
INPRED=&quot;$INDIR/DLPFC.ensembl.KNOWN_AND_SVA.ADJUST.SAMPLE_COVARIATES.tsv&quot;
INID=&quot;$INDIR/samples.csv&quot;

# script files
SCRIPT=$PDIR/src/predictors-for-R

# run scripts
test -d $OUTDIR || $SCRIPT $INPRED $INID $OUTDIR
echo &quot;output files:&quot;
file $OUTDIR/*
</code></pre>

<pre><code>## output files:
## /home/attila/projects/monoallelic-brain/data/predictors//predictors.csv:             ASCII text, with very long lines
## /home/attila/projects/monoallelic-brain/data/predictors//RNAseq_ID.DLPFC_RNA_ID.csv: ASCII text
</code></pre>

<h2>Importing into <code>R</code></h2>

<h3>Observed predictors and read counts</h3>

<p>We will generate a data frame <code>E</code> representing matrix \(E\) such that each column holds the observed values of some predictor (explanatory variable).  During the fitting of some regression model <code>R</code> will automatically construct the design matrix \(X\) from \(E\) (or a submatrix of \(E\) if we omit some predictors) by making contrasts for categorical predictors (i.e. factors).</p>

<p>To get as set of responses for regression, we will also generate a list <code>Y</code> of data frames representing the set of matrices \(Y = \{ Y_g : g\in\mathcal{G} \}\) so that each matrix \(Y_g\) corresponds to gene \(g\) in a selected set \(\mathcal{G}\).  The columns of \(Y_g\) are either the observed values \(H_g\) (or \(L_g\)) of the &ldquo;higher&rdquo; (or &ldquo;lower&rdquo;) read counts for \(g\), respectively, or the observed values of derived statistics.  These derived statistics are the total read count \(N_g = L_g + H_g\), the ratio \(S_g = H_g / N_g\), whose rank-transformation yields \(R_g\).  For all matrices \(E, Y_{g_1}, Y_{g_2},&hellip;\) the rows correspond to \(n\) observations, that is \(n\) RNA samples, each from a different individual.</p>

<p>\(\mathcal{G}\) is defined by the <code>gene.ids</code> below:</p>

<pre><code class="r">             # 8 genes analyzed by Ifat
gene.ids &lt;- c(&quot;PEG3&quot;, &quot;INPP5F&quot;, &quot;SNRPN&quot;, &quot;PWAR6&quot;, &quot;ZDBF2&quot;, &quot;MEG3&quot;, &quot;ZNF331&quot;, &quot;GRB10&quot;,
             # 5 more genes analyzed by AGK 3/2/16
             &quot;PEG10&quot;, &quot;SNHG14&quot;, &quot;NAP1L5&quot;, &quot;KCNQ1OT1&quot;, &quot;MEST&quot;,
             # 3 more genes present in data files
             &quot;IGF2&quot;, &quot;NLRP2&quot;, &quot;UBE3A&quot;,
             # &#39;green&#39; novel 1 MB imprinted genes; note that PWAR6 is already included above
             &quot;TMEM261P1&quot;, &quot;AL132709.5&quot;, &quot;RP11-909M7.3&quot;, &quot;SNORD116-20&quot;, &quot;RP13-487P22.1&quot;, &quot;hsa-mir-335&quot;, &quot;PWRN1&quot;)
</code></pre>

<h3>Aggregations</h3>

<p>We will redefine \(Y\) after appending (horizontally concatenating) to it the set of matrices \(\{Y_{a_k\mathcal{G}_l} : k=1,2 \;;\; l=1,2,&hellip; \}\), indexed by combinations of an aggregation method \(a_l\) and a gene subset \(\mathcal{G}_l\subset\mathcal{G}\).  \(a_1\) is aggregation of \(\{S_g : g\in\mathcal{G}_l\}\) (or the corresponding \(\{R_g\}\)) by weighted average (<code>WA</code>) using total read count weights \(\{N_g\}\), whereas \(a_2\) is unweighted average (<code>UA</code>).  Ifat&#39;s original analysis combined <code>UA</code> with the subset given by <code>gene.ids[1:8]</code>.  Thus, for observation \(i\) the we have \(\bar{S}_{i;k\mathcal{G}_j} = \left( \sum_{g\in\mathcal{G}_l} W_{ig} \right)^{-1} \sum_{g\in\mathcal{G}_l} W_{ig} S_{ig}\), where \(W_{ig}=N_{ig}\) if \(k=1\) (<code>WA</code>) and \(W_{ig}=1\) if \(k=2\) (<code>UA</code>).  Rank transformation of \(\bar{S}_{i;k\mathcal{G}_j}\) yields \(\bar{R}_{i;k\mathcal{G}_j}\).</p>

<h3>Filtering</h3>

<p>Given threshold \(t\) (<code>count.thrs</code>) and gene \(g\), an observation \(i\) is filtered out whenever \(N_{ig}\le t\).  For weighted average over a subset \(\mathcal{G}_l\) the filtering rule is \(\sum_{g\in\mathcal{G}_l} N_{ig}\le t\); consequently for observation \(i\) the statistic \(S_{ig}\) may be filtered out from some individual genes \(g\in\mathcal{G}_l\) but may still contribute to the weighted average \(\bar{S}_{i;k\mathcal{G}_j}\).  This is not the case for unweighted averages, which are derived from gene-wise statistics only <em>after</em> those have been filtered.</p>

<h3>Results</h3>

<h4>New implementation</h4>

<p>Using the new implementation&hellip;</p>

<pre><code class="r">source(&quot;~/projects/monoallelic-brain/src/import-data.R&quot;)
</code></pre>

<pre><code class="r"># default arguments given explictely to both function calls
E &lt;- get.predictors(f.predictors = &quot;~/projects/monoallelic-brain/data/predictors/predictors.csv&quot;,
                      f.rna.ids = &quot;~/projects/monoallelic-brain/data/predictors/RNAseq_ID.DLPFC_RNA_ID.csv&quot;)
Y &lt;- get.readcounts(gene.ids = gene.ids,
                           data.dir = &quot;~/projects/monoallelic-brain/data/readcount/genes&quot;,
                           count.thrs = 50,
                           sel.obs = row.names(get.predictors()),
                           g.subsets = list(A.8 = gene.ids[1:8], A = gene.ids))
</code></pre>

<pre><code>## Warning in max(y, na.rm = TRUE): no non-missing arguments to max; returning
## -Inf
</code></pre>

<p>The warning (if any) about the arguments to <code>max</code> may arise when all observations are filtered out for some gene like for TMEM261P1:</p>

<pre><code class="r">sapply(Y, function(y) sum(! is.na(y)))
</code></pre>

<pre><code>##          PEG3        INPP5F         SNRPN         PWAR6         ZDBF2 
##          2460          1980          1580          1930          1930 
##          MEG3        ZNF331         GRB10         PEG10        SNHG14 
##          2320          1285           970          1845          2375 
##        NAP1L5      KCNQ1OT1          MEST          IGF2         NLRP2 
##           915           955          1185            70           140 
##         UBE3A     TMEM261P1    AL132709.5  RP11-909M7.3   SNORD116-20 
##            95             0           665            55           925 
## RP13-487P22.1   hsa-mir-335         PWRN1          WA.8            WA 
##            35            20            50          2890          2890 
##          UA.8            UA 
##          1156          1156
</code></pre>

<h4>Agreement with previous implementation</h4>

<p>Comparing with my previous implementation (which was shown to give results consistent with Ifat&#39;s)&hellip;</p>

<pre><code class="r">source(&quot;../2016-04-22-glm-for-s-statistic/2016-04-22-glm-for-s-statistic.R&quot;)
source(&quot;../2016-04-22-glm-for-s-statistic/2016-04-22-glm-for-s-statistic-run.R&quot;)
</code></pre>

<p>The old (left arguments) and new (right arguments) implementation agree perfectly on \(N_g\) and \(\bar{R}_{i;k\mathcal{G}_j}\).  For instance:</p>

<pre><code class="r">c(identical(d$N_MEST, Y$MEST$N),
identical(d$R_MEST, Y$MEST$R),
identical(d$R_avg8, Y$UA.8$R))
</code></pre>

<pre><code>## [1] TRUE TRUE TRUE
</code></pre>

<p>But there are slight differences regarding \(S_g\) because the new implementation calculates it afresh from \(L_g\) and \(H_g\) whereas the old implementation imported rounded numbers from Ifat&#39;s <code>pop_skew_3June15.txt</code> file loosing some precision.</p>

<pre><code class="r">c(identical(d$S_MEST, Y$MEST$S), all.equal(d$S_MEST, Y$MEST$S))
</code></pre>

<pre><code>## [1] FALSE  TRUE
</code></pre>

<p>Moreover:</p>

<pre><code class="r">c(identical(d$S_avg8, Y$WA.8$S), all.equal(d$S_avg8, Y$WA.8$S))
</code></pre>

<pre><code>## [1] &quot;FALSE&quot;                                
## [2] &quot;Mean relative difference: 0.001112457&quot;
</code></pre>

<pre><code class="r">c(identical(d$S_avg8, Y$UA.8$S), all.equal(d$S_avg8, Y$UA.8$S))
</code></pre>

<pre><code>## [1] &quot;FALSE&quot;                                
## [2] &quot;Mean relative difference: 0.009172348&quot;
</code></pre>

<p>which shows that the <code>S_avg8</code> statistic corresponds to the <code>WA.8</code> weighted average \(\bar{S}_{i}\) more closely than to the unweighted <code>UA.8</code>.  Analyzing the code of the old implementation in <code>../2016-04-22-glm-for-s-statistic/2016-04-22-glm-for-s-statistic.R</code> confirms this.</p>

<p>Finally, note that the names of predictors have been simplified in the new implementation:</p>

<pre><code class="r">str(E[ , 1:15])
</code></pre>

<pre><code>## &#39;data.frame&#39;:    579 obs. of  15 variables:
##  $ Institution  : Factor w/ 3 levels &quot;MSSM&quot;,&quot;Penn&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ Gender       : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 1 1 2 1 1 2 1 2 ...
##  $ Age          : int  42 58 28 36 52 78 49 62 60 51 ...
##  $ PMI          : num  22.3 19.5 22.8 17.3 22.2 16 20 20.8 24 21.3 ...
##  $ Dx           : Factor w/ 3 levels &quot;AFF&quot;,&quot;Control&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ RIN          : num  6.9 7 6.9 6.9 7.6 7.4 8 8.4 7.7 7.9 ...
##  $ RIN2         : num  47.6 49 47.6 47.6 57.8 ...
##  $ RNA_lib_batch: Factor w/ 9 levels &quot;0&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,..: 6 6 5 6 2 7 8 7 6 3 ...
##  $ Ancestry_EV.1: num  0.0214 0.0213 0.0202 0.0213 0.0213 ...
##  $ Ancestry_EV.2: num  0.00459 0.03477 -0.00671 0.02264 -0.00656 ...
##  $ Ancestry_EV.3: num  -0.003252 0.002797 0.000894 0.003056 0.006738 ...
##  $ Ancestry_EV.4: num  0.0381 -0.0202 0.0461 -0.0182 0.041 ...
##  $ Ancestry_EV.5: num  0.000824 -0.00345 -0.005654 -0.007156 -0.013422 ...
##  $ SV1          : num  0.02559 -0.00105 -0.00124 0.02031 -0.02787 ...
##  $ SV2          : num  -0.00651 -0.04842 -0.00523 -0.01151 -0.00416 ...
</code></pre>

